'''
 A trie data structure is a particular kind of tree which exploits the fact that strings we seek to store are in an underlying alphabet.
 For example, suppose our alphabet is {0,1,2,3}. And suppose we want to store the set of strings {010,00,0100,210,1231,12}.
 Assuming 0 < 1 < 2 < 3 and adopting the corresponding lexicographic ordering for the strings, we could store those strings in a binary search tree that may look like the following. 
 12
210010
00 0100 1231
Instead, in a trie, each node can be thought of as an array of pointers, each corresponding to each entry in the alphabet. 
So, in our case, each node is an array of size 4, which we assume correspond to the alphabet symbols 0,1,2,3, in left-to-right order.
A trie that corresponds to the above set of strings would then look like the picture below. 
To search for a string, we start at the top node, and follow down the trie, symbol-by-symbol. 
The bolded nodes are terminal nodes, which indicate that a string terminates at that symbol. 
For example, if we were to search for the string â€œ21â€ in the above trie, we would arrive at the penultimate node in the rightmost branch. 
That node is not a terminal node, and thereby, we discover that the string â€œ21â€ is not in the set. If we instead search for â€œ010,â€ we arrive at the penultimate node in the second branch from the left, which is a terminal node. 
Thereby, we discover that that string is indeed in the set. Any string that begins with the symbol 3 we would discover is not in the set simply by observing that at the root node, the slot that corresponds to 3 is Nil. 
This is also how we would discover that the string â€œ1220â€ is not in the set â€“ we would fail at the second â€˜2.â€™
What you need to do you need to implement three methods. 
trieInsert(t,s) â€“ inserts the string s in the alphabet {0,1,2,3} into the trie t. If s is already in t, then this method does nothing. 
trieDelete(t,s) â€“ deletes the string s from the trie t. If s is not in t, then this method does nothing. 
trieFind(t,s) â€“ returns True if the string s is in t, and False otherwise. 
Structure of a trie We model each node in the trie as a list of two items: (i) a list, and, (ii) True or False.
The list (i) has four items, each corresponding to each alphabet symbol. 
We use an empty list [] for what we refer to as a Nil pointer above.
Each entry in the list (i) may itself be a trie node, i.e., a list of two items (i) and (ii). 
The boolean entry (ii) for a node indicates whether this node is a terminal. 
We adopt the convention that a trie t = [], i.e., an empty list, if and only if the trie t is empty, i.e., has no strings in it.
Thus, if t is [[[], [], [], []], True], then t is a trie that comprises the empty string, which is often represented as , but in python would be â€™â€™. 
Note that [[[], [], [], []], False] is not a valid trie. More generally, every leaf node should be a terminal. 
The trie [[[], [[[], [], [], []], True], [], []], False] contains only one string, â€˜1.â€™
The trie [[[[[], [], [], []], True], [[[[[], [], [], []], True], [], [], []], False], [], []], True] contains three strings: , â€˜0â€™ and â€˜10.â€™
The trie from the above picture, which encodes the set of strings {010,00,0100,210,1231,12}, is in the tester.
'''
